from argparse import ArgumentParser
import os
import re
from typing import TextIO
from datetime import datetime

from hermes_gen import hermes_logs
from hermes_gen.code_preproc import CodePreprocessor
from hermes_gen.grammar import Grammar
from hermes_gen.parseTable import ParseTable, Action
from hermes_gen.directives import Directive


class PyCodePreproc(CodePreprocessor):

    def _getNonterminal(self, sIdx: int) -> str:
        return f'values[{sIdx}].nt'

    def _getTerminal(self, sIdx: int) -> str:
        return f'values[{sIdx}].token'

    def _getLoc(self, sIdx: int) -> str:
        return f'values[{sIdx}].loc'


def writeHermesHeader(f: TextIO):
    header = ("#*******\n"
              "# This file was generated by Hermes, do not edit\n"
              f'# {datetime.now()}\n'
              "#*******\n")

    f.write(header)


def getArguments(parser: ArgumentParser):
    parser.add_argument("--output", help="Output implementation file", required=True)


def generate(grammar: Grammar, parseTable: ParseTable, args):
    outputFile = str(args.output)
    name: str = args.name

    with open(outputFile, mode='w') as f:
        writeHermesHeader(f)

        f.write(
            "from typing import List, Callable\n"
            "from hermes_py.parser import TerminalDef, Reduction, StackItem, ParseAction, ReductionFunc, Parser\n"
        )

        f.write("# Begin user directed headers\n")
        headers = grammar.directives[Directive.header]
        for header in headers:
            f.write(header)
        f.write("# End user directed headers\n\n")

        f.write("E = 0\n"
                "S = 1\n"
                "R = 2\n"
                "G = 3\n\n")

        f.write("class Symbol:\n")
        for idx, terminal in enumerate(parseTable.symbolList):
            f.write(f"    {terminal.name} = {idx}\n")
        f.write(f"    __IGNORE__ = {len(parseTable.symbolList)}\n")
        f.write(f"# End class Symbol\n\n")

        f.write("SYMBOL_LOOKUP: List[int] = [\n")
        for idx, terminal in enumerate(parseTable.symbolList):
            f.write(f"    Symbol.{terminal.name},\n")
        f.write(f"    Symbol.__IGNORE__ \n")
        f.write("] # End SYMBOL_LOOKUP\n\n")

        def escape_regex(r: str) -> str:
            regex = re.sub(r'"', r'\\"', r)
            regex = re.sub(r"\\", r"\\\\", regex)
            return regex

        f.write("TERMINALS: List[TerminalDef] = [")
        for idx, terminal in enumerate(parseTable.terminals):
            regex = escape_regex(terminal.regex)
            f.write(f'    TerminalDef(Symbol.{terminal.name}, b"{regex}"),\n')
        # Write ignored terminals
        if Directive.ignore in grammar.directives:
            for ignore in grammar.directives[Directive.ignore]:
                regex = escape_regex(ignore)
                f.write(f'    TerminalDef(Symbol.__IGNORE__, b"{regex}"),\n')
        f.write("] # End TERMINALS\n\n")

        f.write("_R = Reduction\n")
        f.write("REDUCTIONS: List[Reduction] = [\n")
        for idx, rule in enumerate(grammar.rules):
            # Plus 1 to re-offset for the start symbol
            f.write(f'    _R({len(rule.symbols)}, {parseTable.symbolIDs[rule.nonterm] + 1}),\n')
        f.write("] # End REDUCTIONS\n\n")

        preproc = PyCodePreproc(grammar)

        returnType = grammar.directives[Directive.return_][0]

        for idx, rule in enumerate(grammar.rules):
            code = preproc.preproc(rule)
            f.write(
                f'def r{idx}(values: List[StackItem]) -> {returnType}:\n'
                f'    #line {rule.codeLine} "{rule.file}\n'
            )

            for line in code.splitlines(keepends=True):
                f.write("    ")
                f.write(line)

            f.write("\n\n")

        f.write("\n")

        f.write("REDUCTION_FUNCS: List[ReductionFunc] = [\n")
        for idx, rule in enumerate(grammar.rules):
            f.write(f'    r{idx},\n')
        f.write("] # End REDUCTION_FUNCS\n\n")

        tableRows = len(parseTable.table)
        tableCols = len(parseTable.table[0])

        f.write(
            f"TABLE_ROWS = {tableRows}\n"
            f"TABLE_COLS = {tableCols}\n"
            "_A = ParseAction\n"
            "PARSE_TABLE: List[List[ParseAction]] = [\n"
        )

        for row in parseTable.table:
            f.write("[")
            for action in row:
                if action.action != Action.E:
                    f.write(f'_A({action.action}, {action.state}),')
                else:
                    f.write("_A(),")
            f.write("],\n")
        f.write("] # End PARSE_TABLE\n\n")

        f.write(
            f"def load_{name}() -> Parser:\n"
            "    return Parser(SYMBOL_LOOKUP, TERMINALS, REDUCTIONS, REDUCTION_FUNCS, PARSE_TABLE)\n"
        )
